<?xml version="1.0" encoding="UTF-8" ?>

<!--********************************************************************
Copyright 2013 Robert A. Beezer

This file is part of MathBook XML.

MathBook XML is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 or version 3 of the
License (at your option).

MathBook XML is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MathBook XML.  If not, see <http://www.gnu.org/licenses/>.
*********************************************************************-->

<!--
To process this file, at the command-line issue:

xsltproc /path/to/mathbook/xsl/pretext-html.xsl /path/to/mathbook/examples/sample-article.xml

then find  "derivatives.html"  in the current working directory
and use a web browser to view.  For PDF/print, issue:

xsltproc -o derivatives.tex /path/to/mathbook/xsl/mathbook-latex.xsl /path/to/mathbook/examples/sample-article.xml

and apply  pdflatex  or  xelatex  to  "derivatives.tex"  in
the current working directory.

Ignore any warnings, they are part of testing the warning system.

To see images in your results, copy the examples/images directory
so that your working directory has the images subdirectory.  See
the  pretextbook.org  website for information on installing
the xsltproc executable.
-->

<!-- Overall element for a Mathbook XML document; mandatory, always  -->
<!-- Experiment with the "xml:lang" attribute to see localization    -->
<!-- changes, the  xsl/localizations  directory has more information -->
<pretext xml:lang="pt-BR">
<!-- <pretext xml:lang="pt-BR"> -->
<!-- <pretext xml:lang="fr-FR"> -->
<!-- <pretext xml:lang="cs-CZ"> -->
<!-- <pretext xml:lang="af-ZA"> -->

    <!--
    "docinfo" is like metadata, it is necessary technical
    information which a reader mostly will never see.  LaTeX
    macros and Web analytics project numbers are good examples.
    If you are getting started, you do not need any of this initially.
    So on a first reading, skip ahead to the article tag.
    -->
    <docinfo>
        <!--
        In the HTML version there is room for a picture or logo
        in the upper left corner.  An image of a cover for a
        physical version is a good choice to go here.  We use
        16th Century Art Book Cover, 176x240 pixels, Public Domain, due to age
        http://commons.wikimedia.org/wiki/File:Book_Cover_-_Google_Art_Project.jpg
        -->
        <!--<brandlogo url="https://pretextbook.org" source="images/book-cover-google-art-project.jpg" />-->
        <!--
        LaTeX packages that are also implemented as MathJax extensions
        may be specified here and any macros they have in common may be
        used within mathematics.  See below in the "Mathematics" section
        an example of the use of the "\cancelto{}{}" macro from
        the "cancel" package.
        -->
        <latex-preamble>
            <package>cancel</package>
        </latex-preamble>
        <!--
        TeX/LaTeX macros can be written in the usual way.
        Whitespace and line breaks are irrelevant here.
        These are "write once, use everywhere".
        -->
        <macros>
        \newcommand{\definiteintegral}[4]{\int_{#1}^{#2}\,#3\,d#4} % this comment will be stripped
        \newcommand{\myequation}[2]{#1\amp =#2} % testing alignment override
        % comments anywhere get stripped, with or without faux % comment \% characters
        \newcommand{\indefiniteintegral}[2]{\int#1\,d#2}
        \newcommand{\testingescapedpercent}{ \% } % just testing
        </macros>
        <!-- We control the appearance of the text of cross-references here           -->
        <!-- (these are the "xref" elements).  Because this changes the words         -->
        <!-- that appear in your output, it is a decision with stays with the source. -->
        <!-- Experiment here with different choices and a few different "xref"        -->
        <!-- elements before you decide on a final choice.  We set this to 'global',  -->
        <!-- not because we think it is a good choice, but for historical reasons.    -->
        <!-- The default is 'type-global', which produces text like "Theorem 5.2",    -->
        <!-- where "Theorem" will be translated into the document language            -->
        <cross-references text="global" />
        <!--
        Extra packages, package options, and package settings for latex-based images.
        Inserted in the preamble for LaTeX output.
        Inserted in the preamble to each standalone latex-based image for HMTL SVG output.
        -->
        <latex-image-preamble>
        \usepackage{pgfplots}               % loads tikz package
        \usepackage{smartdiagram}           % for a circular diagram
        \pgfplotsset{axis x line = middle,
                     axis y line = middle}
        \usetikzlibrary{backgrounds}
        \usetikzlibrary{arrows,matrix}
        \usetikzlibrary{positioning}        % for Dave R's worksheet
        \usepackage{circuitikz}             % for Virgil P's worksheet
        </latex-image-preamble>
        <!--
        The Sage Notebook has its own interface and worksheet list.
        To use the sorting features optimally, it helps to have subdivisions
        begin with the same short prefix.  An "initialism" (nee acronym)
        here will be used for that purpose if present.  This is only employed
        for producing Sage notebook versions and in the title shown in the
        browser. (If not present, you will get a harmless warning just for
        Sage worksheet production.)
        -->
        <initialism>REVISTA</initialism>
        <!-- For various purposes, it is helpful to have a unique identifier    -->
        <!-- for your entire document.  As of 2019-01-02 this will be used as   -->
        <!-- the HTML id attribute on the body element of *every* page created  -->
        <!-- by the HTML conversion.                                            -->
        <!--                                                                    -->
        <!--   * Start with a letter                                            -->
        <!--   * No strange characters, just 52 Latin letters, and 10 digits    -->
        <!--   * No spaces                                                      -->
        <!--   * Use only a hyphen (-) to separate words                        -->
        <!--                                                                    -->
        <!-- Make it so there is a reasonable expectation of being unique.      -->
        <!-- "my-book" is a poor choice, "beezer-first-course-linear-algebra"   -->
        <!-- is better.  And maybe something in-between is best: "beezer-FCLA". -->
        <document-id>pretext-SA</document-id>
        <!-- Items peculiar to an HTML output -->
        <html>
            <!-- Expects favicon/favicon-32x32.png, and favicon/favicon-16x16.png -->
            <favicon/>
            <!-- There does not need to be a trailing / on the URL             -->
            <!-- NB Eventually a publisher option will exist to overrule this, -->
            <!-- so a given source can be installed more than one place        -->
            <baseurl href="https://pretextbook.org/examples/sample-article/html" />
        </html>
        <!--
        With a <feedback> element, in the HTML version, you get a button
        for reporting typos and errors.  You might link to a Google Docs
        spreadsheet or something similar.  Default is to get a button
        labeled "Feedback", which will be localized to your target language.
        You can override this with some text of your choosing, but then you
        lose the localization feature.
        -->
        <feedback>
            <url>not-implemented.html</url>
             <!-- <text>My Button Text</text>  -->
        </feedback>

        <!--
        "Names" for various parts of a document are determined exactly
        once for each language, ensuring consistency and saving you the
        bother of always typing them in.  These can be found in the
        files in the  xsl/localizations  directory.

        You can make a document-specific, global override.  Here we
        decide we have no need for any "proposition"s and repurpose
        that environment as a "Conundrum."

        The specification of a language is optional, if you do not
        have a multilingual project.  Otherwise you can supply an
        @xml:lang attribute so the rename only applies for a specific
        language.  See the localization file for more on language codes.
        -->
        <!-- <rename element="proposition">Conundrum</rename> -->

        <!-- Images in HTML output may carry a discreet list of links    -->
        <!-- to "archival" versions of images in a variety of formats.   -->
        <!-- Authors have complete freedom to do this as they choose,    -->
        <!-- along with complete responsibility to provide the actual    -->
        <!-- files, with proper filenames and suffices.  Search this     -->
        <!-- source file for "archive=" to see particular examples.      -->
        <!-- The following demonstrates a global specification, which    -->
        <!-- we just use for testing - it just makes totally fake links. -->
        <!--
        <images>
            <archive>One Two Three</archive>
        </images>
        -->

        <!-- Demonstration of subtree specifications for archive formats -->
        <!-- (Do not use in concert with above global test)              -->
        <!-- Chapter on graphics, fake "A B" links throughout            -->
        <!-- No other part of the @archive scheme is affected            -->
        <!-- Two images, inside figures, within graphics chapter         -->
        <!--   1) one has "A B" links turned off                         -->
        <!--   2) single link "exceptional"                              -->
        <!--
        <images>
            <archive from="graphics">A B</archive>
            <archive from="figure-asymptote-levers" />
            <archive from="figure-asymptote-contour-plot">exceptional</archive>
        </images>
        -->

        <latex-output>
            <!-- turn this on once it is easier to make   -->
            <!-- standalone worksheets, uncomment to test -->
            <!-- <worksheet top="3cm" left="4cm" margin="12cm"/> -->
        </latex-output>

    </docinfo>

    <!--
    The article element is top-level for anything short of a book.
    There is a book element, which is not demonstrated here.
    The "xml:id" attribute will be used for the filename of the
    HTML output.
    -->
    <article xml:id="artigo-frobenius">
        <title>O Problema das Moedas de Frobenius</title>
        <subtitle>Uma abordagem Olímpica e Computacional</subtitle>

        <!--
        The frontmatter contains a variety of items that precede
        the actual content.  They should be placed in the proper order,
        here the title material should precede a table of contents.
        They differ from "docinfo" items in that they will be *content*
        that a reader will actually see.
        -->

        <frontmatter xml:id="frontmatter">
            <!--
            Items typically on the main title page of a book,
            but here as an article they are handled more compactly
             -->

            <titlepage>

               <!-- There can be several authors here -->
                
                
                
                <author>
                    <personname>Jogli Gidel da Silva Araújo</personname>
                    <!-- department here is one line, so unstructured -->
                    <department>Departamento de Matemática</department>
                    <!-- institution uses two lines, so structured as such -->
                    <institution>
                        <line>Universidade Federal Rural de Pernambuco - UFRPE</line>
                        <line>Recife, Pernambuco, Brasil</line>
                    </institution>
                    <email>jogli.silva@ufrpe.br</email>
                </author>

                <author>
                    <personname>Ricardo Nunes Machado Junior</personname>
                    <!-- department here is one line, so unstructured -->
                    <department>Departamento de Matemática</department>
                    <!-- institution uses two lines, so structured as such -->
                    <institution>
                        <line>Universidade Federal Rural de Pernambuco - UFRPE</line>
                        <line>Recife, Pernambuco, Brasil</line>
                    </institution>
                    <email>ricardo.machadojunior@ufrpe.br</email>
                </author>  
                
                <author>
                    <personname>Thiago Yukio Tanaka</personname>
                    <!-- department here is one line, so unstructured -->
                    <department>Departamento de Matemática</department>
                    <!-- institution uses two lines, so structured as such -->
                    <institution>
                        <line>Universidade Federal Rural de Pernambuco - UFRPE</line>
                        <line>Recife, Pernambuco, Brasil</line>
                    </institution>
                    <email>thiago.tanaka@ufrpe.br</email>
                </author>
          

                <!-- Can set date manually or use the "today" element -->
                <date><today /></date>

            </titlepage>

            <abstract>
                <p>Sejam todas e todos bem-vindas e bem-vindos ao complemento do artigo: "O Problema das Moedas de Frobenius: Uma abordagem Olímpica e Computacional", submetido à Revista Eletrônica da Matemática (REMAT). Se você chegou até aqui através de nosso trabalho, descobrirá um complemento da parte computacional que desenvolvemos para a construção de nosso artigo. </p>

                <p>Destacamos dentre as ferramentas computacionais disponibilizadas:
                <ol>
                <li>O Algoritmo de Euclides para o cálculo de MDC;</li>
                <li>A solução geral para uma equação diofantina linear (em qualquer dimensão).</li>
                <li>Gráfico com algumas soluções de Equações Diofantinas Lineares de dimensão 2.</li>
                <li>A solução do número de Frobenius em dimensão 2 e dimensão 3. </li>
                </ol> 
                Estas tecnologias podem auxiliar bastante o estudo no tema das Equações Diofantinas uma vez que permitem não apenas rápidas soluções para o problema, mas também processos intermediários detalhadamente escritos.</p>

                <p>Esperamos que vocês gostem, usem e abusem da tecnologia disponibilizada!</p>
            </abstract>
            <!--
            Acknowledgements, dedications, colophon (ISBN, copyright, etc)
            are supported in the book document type.  Such a diverse range
            is not yet available for articles.  Send requests.
             -->
        </frontmatter>

        <!--
        Articles have sections, which have subsections,
        which have subsubsections.These are all "containers"
        and so line breaks and extraneous whitespace gets
        scrubbed.  Use indentation and line breaks liberally
        within containers to make the structure of your
        source readable.
        -->

 

        <!--
        Note above: Subdivisions always have titles, and these
        are not containers.  Line breaks and whitespace will
        bleed into output, which is especially a problem for TeX,
        since it may render as a blank line.  So keep the title
        element "tight" around the content.

        The "p" element is a paragraph, and also not a container,
        so keep it wrapped tight.  Lots can go on in a paragraph.
        -->


        <!--
        Sage Code: Next section has Sage code examples.
        For HTML it renders as Sage Cells, with no sample output.
        For LaTeX it renders as input/output, suggestively typeset.
        A separate XSL transform isolates code and produces a file
        for doctesting.

        Note: These small examples are wrapped "tight" in the
        input and output elements.  For multiline code snippets,
        the left margin is determined by the whitespace preceding
        the first non-trivial character.
        -->

<!--       <section  xml:id="section-sage-cells">
            <title>Gráficos de EDOs de Sistemas Lineares</title>
            
          

    <introduction>
   	<p>Nesta seção deixamos disponíveis modelos interativos dos gráficos apresentados no artigo XXX</p>
   	</introduction>

<p>Uma vez que as informações sejam alteradas, o gráfico será atualizado ao apertar em Tab ou quando for "clicado" fora do campo alterado.</p>

<technology>
    <title>Faça você mesmo</title>
<figure xml:id="interactive-binomio">
<caption>Teste</caption>
<p>Gráfico das trajetórias do sistema:
<me> x' = \newcommand{\Bold}[1]{\mathbf{#1}}\left(\begin{array}{rr}
1 \amp 1 \\
4 \amp 1
\end{array}\right)x. </me>
</p>
    <interactive xml:id="interactive-teste" platform="sage" aspect="1:1.3" >
    <slate surface="sage">                    
@interact
def _(edox=input_box([[1,1],[4,1]] , width=40,  label="matriz:"), imin=input_box(-5 , width=10,  label="imin:"), imax=input_box(5 , width=10,  label="imxn:"),
passo=input_box(0.5 , width=10,  label="passo:"), tmin=input_box(-1.5 , width=10,  label="tmin:"), tmax=input_box(1.5 , width=10,  label="imax:"), vetores=False):
            
    t = var('t')
    x=function('x')(t)
    y=function('y')(t)
    edo = [diff(x, t) == edox[0][0]*x+edox[0][1]*y, diff(y, t) == edox[1][0]*x+edox[1][1]*y]

    G = Graphics()
    for i in srange(imin, imax, passo):
        sol = desolve_system(edo, [x, y], [0,i,0])
        G = G + parametric_plot((sol[0].rhs(), sol[1].rhs()), (t, tmin, tmax))

    for i in srange(imin, imax, passo):
        sol = desolve_system(edo, [x, y], [0,0,i])
        G = G + parametric_plot((sol[0].rhs(), sol[1].rhs()), (t, tmin, tmax), color='green', ymin=-4, ymax=4, frame=True)

    if vetores==False:
        return (G).show(xmin=-4, xmax=4, figsize=[4,4])
    elif vetores==True:
        u, v = var('u v')
        x0 = edo[0].rhs().subs(x==u, y==v)
        x1 = edo[1].rhs().subs(x==u, y==v)
        
        P = plot_vector_field(vector((x0, x1))/norm(vector((x0, x1))), (u, -4, 4), (v, -4, 4))
    
        return (P+G).show(xmin=-4, xmax=4, figsize=[4,4])


    </slate>
    </interactive>        
</figure>
<p>Os códigos no Sage são os seguintes:</p>
<sage>
<input>t = var('t')
x=function('x')(t)
y=function('y')(t)
G = Graphics()
for i in srange(-5, 5, 0.5):
    sol = desolve_system([diff(x, t) == x+y, diff(y, t) == 4*x+y], [x, y], [0,i,0])
    G = G + parametric_plot((sol[0].rhs(), sol[1].rhs()), (t, -1.5, 1.5))
    
for i in srange(-5, 5, 0.5):
    sol = desolve_system([diff(x, t) == x+y, diff(y, t) == 4*x+y], [x, y], [0,0,i])
    G = G + parametric_plot((sol[0].rhs(), sol[1].rhs()), (t, -1.5, 1.5), color='green', ymin=-4, ymax=4)
(G).show(xmin=-4, xmax=4, figsize=5)  
</input>
<output>
</output>
</sage>
</technology>


<technology>
    <title>Faça você mesmo</title>
<figure xml:id="interactive-binomio2">
<caption></caption>
<p>Gráficos de <m>x_i</m> em função de <m>t</m>, do sistema:
<me> x' = \newcommand{\Bold}[1]{\mathbf{#1}}\left(\begin{array}{rr}
1 \amp 1 \\
4 \amp 1
\end{array}\right)x. </me>
</p>
    <interactive xml:id="interactive-teste2" platform="sage" aspect="1:0.8" >
    <slate surface="sage">                    
@interact
def _(edox=input_box([[1,1],[4,1]] , width=40,  label="matriz:"), passo=input_box(0.4 , width=10,  label="passo:")):
    t, x, y = polygens(RR, 't, x, y')
    
    G = Graphics()
    for j in srange(-3, 3, passo):
        G = G + eulers_method_2x2_plot(edox[0][0]*x+edox[0][1]*y, edox[1][0]*x+edox[1][1]*y, 0, j, 1.5, 0.01, 1)[0]
    return G.show(figsize=4.2)


    </slate>
    </interactive>        
</figure>
<p>Os códigos no Sage são os seguintes:</p>
<sage>
<input>t, x, y = polygens(RR, 't, x, y')
G = Graphics()
for j in srange(-3, 3, 0.4):
    G = G + eulers_method_2x2_plot(x + y, 4*x + y, 0, j, 1.5, 0.01, 1)[0]
G.show(figsize=5)
</input>
<output>
</output>
</sage>
</technology>

        </section>
-->



<section  xml:id="sec-aritmetica">
            <title>Aritmética dos Inteiros</title>
            <!-- Index testing, semi-realistic -->
          

   <!-- <introduction>
    <p>Usando matrizes, podemos obter os respectivos tabuleiros e polinômios de torre. </p>
    </introduction> -->

<theorem>
<p>
 Sejam <m>a</m> e <m>b</m> números inteiros com <m>b\neq 0</m>. Então existem únicos inteiros <m>q</m> e <m>r</m> tais que 
<me> a=bq+r,\quad \text{com}\quad 0\leq r\lt|b|. </me>
O número <m>a</m> é chamado de <em>dividendo</em>, o número <m>b</m> é chamado de <em>divisor</em>, o número <m>q</m> é chamado de <em>quociente</em> e o número <m>r</m> é chamado de <em>resto</em>.
</p>
</theorem>

<technology>
<p>Escolha valores para <m>a</m> e <m>b</m> para obter os valores do quociente e resto na divisão de <m>a</m> por <m>b</m>.
</p>
<figure width="100%">
    <caption>Divisão Euclideana.</caption>
    <interactive xml:id="interactive-algoritmo-div" platform="sage"  aspect="1:0.5" >
    <slate surface="sage">                    
@interact
def _(a=input_box(-7 , width=10,  label="a:"), b=input_box(-3 , width=10,  label="b:"), auto_update=False):


        def divisao(a, b):
            r=ZZ(mod(a,b))                       # cálculo do resto da 
            q=(a-r)/b                            # cálculo do quociente da 
            print('%d = %d*%d + %d' %(a,b,q,r))  # imprime na tela os valores
        divisao(a, b)
    

    </slate>
    </interactive>        
</figure>

<p>
O algoritmo em SageMath está descrito abaixo:
</p>

<sage>
<input>
def divisao(a, b):
    r=ZZ(mod(a,b))                       # cálculo do resto da divisão de a por b
    q=(a-r)/b                            # cálculo do quociente da divisão de a por b
    print('%d = %d*%d + %d' %(a,b,q,r))  # imprime na tela os valores de a=b*q+r
divisao(-7, -3)
</input>
<output>
</output>
</sage>

</technology>


<definition>
<p>
Sejam <m>a</m> e <m>b</m> dois inteiros, diz-se que o inteiro positivo <m>d</m> é o <em>máximo divisor comum</em> de <m>a</m> e <m>b</m>, e denotamos por <m>d=mdc(a,b)</m>, se <m>d</m> satisfaz as seguintes condições:
<ol label='i'>
<li><m>d</m> é um divisor comum de <m>a</m> e <m>b</m>, ou seja, <m>d|a</m> e <m>d|b</m>;</li>
<li><m>d</m> é divisível por todo divisor comum de <m>a</m> e <m>b</m>, isto é, se <m>c</m> é divisor comum de <m>a</m> e <m>b</m>, então <m>c|d</m>.</li>
</ol>
</p>
</definition>


<technology>
<p>Método <m>\verb|gcd|</m> para calcular MDC.</p>
<sage>
<input>
n = var('n')                #define a variável n
gcd(21*n+4, 14*n+3)         #calcula o MDC entre 21n+4 e 14n+3
</input>
<output>
</output>
</sage>
</technology>

<theorem>
<title>(Algoritmo de Euclides para calcular o MDC)</title> 
<p>
Sejam <m>a</m> e <m>b</m> inteiros positivos. O <m>mdc(a,b)</m> pode ser calculado com os seguintes passos. 
<ol>
    <li>Faça <m>i=1</m>, <m>r_0=max\{a,b\}</m> e <m>r_1=min\{a,b\}</m>;</li>
    <li>Defina <m>r_{i+1}</m> como o resto da divisão de <m>r_{i-1}</m> por <m>r_i</m>, isto é, <m>r_{i-1}=q_ir_i+r_{i+1}</m> com <m>0\leq r_{i+1}\lt r_i</m>;</li>
    <li>Se <m>r_{i+1}\neq0</m> incremete <m>i</m> de 1 e volte para o passo 2, caso contrário <m>mdc(a,b)=r_i</m>.</li>
</ol>
</p>
</theorem>


<technology>
<p>Escolha valores para <m>a</m> e <m>b</m> para obter todos os passos do algoritmo descrito no teorema anterior.
</p>
<figure width="100%">
    <caption>Algoritmo de Euclides para calcular MDC.</caption>
    <interactive xml:id="interactive-algoritmoeu" platform="sage"  aspect="1:0.6" >
    <slate surface="sage">                    
@interact
def _(a1=input_box(88 , width=10,  label="a:"), b1=input_box(25 , width=10,  label="b:"), auto_update=False):


    def mdc(a,b):
        if 1>a or 1>b:
            print('a e b precisam ser maiores que zero')
        else:
            r0 = max([a,b])             # define r0
            r1 = min([a,b])             # define r1
            q=[r0, r0//r1]              # lista para guardar os q's
            r=[r1, r0%r1]               # lista para guardar os r's

            while r[-1] != 0:           # 
                q.append(r[-2]//r[-1])  # Cálculo de todos os
                r.append(r[-2]%r[-1])   # valores dos q's e r's
            q=q[1:]
            print('%d = %d*%d+%d' %(r0, r1, q[0], r[1]))
            for i in range(len(q)-1):
                print('%d = %d*%d+%d' %(r[i], r[i+1], q[i+1], r[i+2]))
            print('\nmdc(%d,%d)=%d' %(a,b,r[-2]))
    
    mdc(a1,b1)
    

    </slate>
    </interactive>        
</figure>

<p>
O algoritmo em SageMath está descrito abaixo:
</p>

<sage>
<input>def mdc(a,b):
    if 1>a or 1>b:
        print('a e b precisam ser maiores que zero')
    else:
        r0 = max([a,b])             # define r0
        r1 = min([a,b])             # define r1
        q=[r0, r0//r1]              # lista para guardar os q's
        r=[r1, r0%r1]               # lista para guardar os r's

        while r[-1] != 0:           # 
            q.append(r[-2]//r[-1])  # Cálculo de todos os
            r.append(r[-2]%r[-1])   # valores dos q's e r's
        q=q[1:]
        print('%d = %d*%d+%d' %(r0, r1, q[0], r[1]))
        for i in range(len(q)-1):
            print('%d = %d*%d+%d' %(r[i], r[i+1], q[i+1], r[i+2]))
        print('\nmdc(%d,%d)=%d' %(a,b,r[-2]))
mdc(25,88)
</input>
<output>
</output>
</sage>

</technology>




<technology>
<p>Dados números inteiros <m>a_1, a_2, \ldots, a_n</m>, não todos nulos, existe seu MDC e  
<me>\mathrm{mdc}(a_1, a_2, \ldots, a_n)=\mathrm{mdc}(\mathrm{mdc}(a_1, a_2), \ldots, a_{n-1}, a_n).</me>
Para obter o MDC de vários números inteiros, digite os números em uma lista como abaixo e aperte no botão "Update".
</p>
<figure width="100%">
    <caption>Algoritmo de Euclides para calcular MDC.</caption>
    <interactive xml:id="interactive-algoritmo-mdc-recursivo" platform="sage"  aspect="1:0.4" >
    <slate surface="sage">                    
@interact
def _(lista=input_box([54, 76, 94, 128] , width=20,  label="lista:"), auto_update=False):


    def mdc_recursivo(lista):
        if 2>len(lista):
            return 'ERRO, a entrada precisa de pelo menos 2 argumentos'
        elif len(lista) == 2:
            return gcd(lista)
        else: 
            lista2  = [gcd(lista[0], lista[1])] + list(lista[2:])
            return mdc_recursivo(lista2)  
    fim = mdc_recursivo(lista)
    print('mdc(%s) = %d' %(lista, fim))
    

    </slate>
    </interactive>        
</figure>

<p>
O algoritmo em SageMath está descrito abaixo:
</p>

<sage>
<input>def mdc_recursivo(lista):
    if 2>len(lista):
        return 'ERRO, a entrada precisa de pelo menos 2 argumentos'
    elif len(lista) == 2:
        return gcd(lista)
    else: 
        lista2  = [gcd(lista[0], lista[1])] + list(lista[2:])
        return mdc_recursivo(lista2)  
mdc_recursivo([54, 76, 94, 128])
</input>
<output>
</output>
</sage>

</technology>


<theorem>
<p><term>(Bachet-Bézout).</term>
Se <m>a</m> e <m>b</m> são inteiros, um dos quais não é nulo, então existem inteiros <m>x</m> e <m>y</m> tais que <me>ax+by=mdc(a,b).</me>
</p>
</theorem>
<!-- 
<p>
Além de partes implementadas em SageMath, vamos mostrar alguns comandos de SageMath para o cálculo do MDC e de soluções para Equações Diofantinas. 
</p> -->

<technology>
<p>Escolha valores para <m>a</m> e <m>b</m> para obter todos os passos até obter o MDC entre <m>a</m> e <m>b</m> os valores de <m>x</m> e <m>y</m>, conforme o Teorema anterior. 
</p>
<figure width="100%">
    <caption>Bachet-Bézout.</caption>
    <interactive xml:id="interactive-algoritmo-mdc-mdc_bachet_bezout" platform="sage"  aspect="1:0.5" >
    <slate surface="sage">                    
@interact
def _(a=input_box(88 , width=20,  label="a:"), b=input_box(25 , width=20,  label="b:"), auto_update=False):


        def mdc_bachet_bezout(a,b):
            if 1>a or 1>b:
                print('a e b precisam ser maiores que zero')
            else:
                r0 = max([a,b])             # define r0
                r1 = min([a,b])             # define r1
                q=[r0, r0//r1]              # lista para guardar os q's
                r=[r1, r0%r1]               # lista para guardar os r's

                while r[-1] != 0:           # 
                    q.append(r[-2]//r[-1])  # cálculo de todos os
                    r.append(r[-2]%r[-1])   #  valores dos q's e r's
                    
                r.reverse()                   # lista dos r's na ordem invertida
                r=r[1:]+[max([a,b])]          # lista dos r's da entrada 1 em diante 
                                              #  adicionada do maximo entre a e b 
                                              
                for i in range(len(r)-2):     # processo de impressão na tela usando
                    x=xgcd(r[i+1],r[i+2])     #  o método xgcd
                    print('%d = %d*(%d) + %d*(%d)' %(r[0],r[i+1],x[1],r[i+2],x[2]))
        mdc_bachet_bezout(a,b)
    

    </slate>
    </interactive>        
</figure>

<p>
O algoritmo em SageMath está descrito abaixo:
</p>

<sage>
<input>def mdc_bachet_bezout(a,b):
    if 1>a or 1>b:
        print('a e b precisam ser maiores que zero')
    else:
        r0 = max([a,b])             # define r0
        r1 = min([a,b])             # define r1
        q=[r0, r0//r1]              # lista para guardar os q's
        r=[r1, r0%r1]               # lista para guardar os r's

        while r[-1] != 0:           # 
            q.append(r[-2]//r[-1])  # cálculo de todos os
            r.append(r[-2]%r[-1])   #  valores dos q's e r's
            
        r.reverse()                   # lista dos r's na ordem invertida
        r=r[1:]+[max([a,b])]          # lista dos r's da entrada 1 em diante 
                                      #  adicionada do maximo entre a e b 
                                      
        for i in range(len(r)-2):     # processo de impressão na tela usando
            x=xgcd(r[i+1],r[i+2])     #  o método xgcd
            print('%d = %d*(%d) + %d*(%d)' %(r[0],r[i+1],x[1],r[i+2],x[2]))
mdc_bachet_bezout(25,88)
</input>
<output>
</output>
</sage>

<p>Método xgcd do SageMath</p>
<sage>
<input>xgcd(88,25)
</input>
<output>
</output>
</sage>

</technology>




<!-- <technology>
<p>Dados <m>a</m> e <m>b</m> números inteiros, os valores de  <m>mdc(a,b)</m>, <m>x</m> e <m>y</m>, tais que
<me>ax+by=mdc(a,b),</me> 
podem ser obtidos usando método <m>xgcd</m>. A saída será uma tripla, contendo o MDC, o valor de <m>x</m> e o valor de <m>y</m>, respectivamente.
</p>
<sage>
<input>xgcd(88,25)
</input>
<output>
</output>
</sage>
<p>
O código abaixo, quando executado, retornará 
"88 * (2) + 25 * (-7) = 1".
Os valores de <m>a</m> e <m>b</m> podem ser trocados.
</p>
<sage>
<input>a=88
b=25
(mdc,x0,y0) = xgcd(a,b)
show('%d * (%d) + %d * (%d) = %d' %(a,x0,b,y0,mdc))
</input>
<output>
</output>
</sage>
</technology> -->

</section>

<section>
    <title>Equações Diofantinas Lineares</title>


<proposition>
<p>
Seja <m>(x_0, y_0)</m> uma solução particular da <em>Equação Diofantina Linear</em> <m>ax+by=c</m>, na qual, <m>mdc(a,b)=1</m>. Então, o seu conjunto solução, é composto pelos pares <m>(x,y)</m> em <m>\mathbb{Z}^2</m> tais que 
<me>x=x_0+tb, \quad y=y_0-ta; \quad t\in \mathbb{Z}.</me>
</p>
</proposition>

<technology>
<p>No SageMath existe um método para resolver equações diofantinas. Para utiliza-lo é necessário declarar cada variável que será usada na equação. Abaixo, declaramos as variáveis <m>x</m> e <m>y</m> e escrevemos os comandos para resolver a equação diofantina
<me> 5x+9y=31. </me>
</p>
<sage>
<input>x,y = var('x,y')
eq = 5*x+9*y==31
show(solve_diophantine(eq))
</input>
<output>
</output>
</sage>
</technology>


<technology>

<p>
Escolha os valores <m>a</m>, <m>b</m> e <m>c</m> para obter algumas soluções inteiras no plano, da Equação Diofantina:
<me>ax+by=c.</me>
</p>
<figure width="100%">
    <caption></caption>
    <interactive xml:id="interactive-reta" platform="sage"  aspect="1:1.2" >
    <slate surface="sage">                    
@interact
def _(a=input_box(3 , width=10,  label="a:"), b=input_box(8 , width=10,  label="b:"), c=input_box(13 , width=10,  label="c:"), auto_update=False):

    def grafDiof(a1,b1,c1, sols=6):
        y, t_0=var('y, t_0')
        if c1%gcd(a1, b1)!=0:
            print('O mcd(%d, %d) não divide %d' %(a1, b1, c1))
        else:
            l=[]
            temp = solve_diophantine(a1*x+b1*y==c1)
            lt=[temp[0], temp[1]]
            yzero = solve(temp[1]==0, t_0)
            yzero = ceil(yzero[0].rhs())
            for i in range(yzero, yzero+ceil(sols/2)):
                l.append((lt[0].subs(t_0=(i)), lt[1].subs(t_0=(i))))
            for i in range(yzero-1, yzero-ceil(sols/2)-1, -1):
                l.append((lt[0].subs(t_0=(i)), lt[1].subs(t_0=(i))))
            
            l.sort()
            pe = l[0]
            pd = l[-1]
            p2=line((pe, pd))
            p1=list_plot(l, size=30, color='red')
            (p2+p1).show(figsize=4)
            print('As soluções destacadas de %dx + %dy = %d são:' %(a1, b1, c1))
            for i in l:
                print(i)
    grafDiof(a, b, c)

    </slate>
    </interactive>        
</figure>
<p>
Abaixo, temos o código em SageMath para a função que calcula algumas soluções e faz o gráfico das Equações Diofantinas Lineares em duas variáveis. 
</p>
<sage>
<input>def grafDiof(a1,b1,c1, sols=6):
    y, t_0=var('y, t_0')
    if c1%gcd(a1, b1)!=0:
        print('O mcd(%d, %d) não divide %d' %(a1, b1, c1))
    else:
        l=[]
        temp = solve_diophantine(a1*x+b1*y==c1)
        lt=[temp[0], temp[1]]
        yzero = solve(temp[0]==0, t_0)
        yzero = ceil(yzero[0].rhs())
        for i in range(yzero, yzero+ceil(sols/2)):
            l.append((lt[0].subs(t_0=(i)), lt[1].subs(t_0=(i))))
        for i in range(yzero-1, yzero-ceil(sols/2)-1, -1):
            l.append((lt[0].subs(t_0=(i)), lt[1].subs(t_0=(i))))
        
        l.sort()
        pe = l[0]
        pd = l[-1]
        p2=line((pe, pd))
        p1=list_plot(l, size=30, color='red')
        (p2+p1).show(figsize=4)
        print('As soluções destacadas de %dx + %dy = %d são:' %(a1, b1, c1))
        for i in l:
            print(i)
grafDiof(5, 9, 31)
</input>
<output>
</output>
</sage>


</technology>


<p>
Não entraremos em detalhes, mas ressaltamos que a função "solve_diophantine" se estende para uma maior quantidade de variáveis e não está restrita ao caso linear. Experimente a equação abaixo e depois substitua a equação por outra.
</p>
<sage>
<input>x,y,z = var('x,y,z') 
eq = 5*x + 9*y + 7*z ==31
show(solve_diophantine(eq))
</input>
<output>
</output>
</sage>



</section>

<section>
    <title>O Problema do Número de Frobenius</title>

<theorem>
<p>
Sejam <m>a</m> e <m>b</m> inteiros positivos com <m>mdc(a,b)=1</m>. Considere a expressão <m>ax+by</m>, com <m>x,y\in\mathbb{Z}_+</m>. O maior inteiro <m>g=g(a,b)</m>, tal que <m>ax+by=g</m> não admite solução, mas <m>ax+by=d</m> admite solução sempre que <m>d\in \mathbb{Z}</m> e <m>d>g</m>, é dado por
<me> g=ab-a-b. </me>
</p>
</theorem>


<technology>

<p>
Número de Frobenius para duas variáveis.
</p>
<figure width="100%">
    <caption></caption>
    <interactive xml:id="interactive-frobenius" platform="sage"  aspect="1:0.7" >
    <slate surface="sage">                    
@interact
def _(a=input_box(3 , width=10,  label="a:"), b=input_box(8 , width=10,  label="b:"), auto_update=False):

        def num_frob(a,b):
            if gcd(a, b)!=1:
                print('Insira valores tais que o mdc seja igual a 1.')
            else:
                g = a*b-a-b
                print('g = %d*%d-%d-%d=%d' %(a, b, a, b, g))
                m = min([a,b])
                M = max([a,b])
                l=[]
                dic={}
                temp=0
                
                print('Abaixo, sendo t inteiro não negativo, temos uma')
                print('parametrização para obter qualquer valor inteiro,') 
                print('maior ou igual a %d que pode ser obtido pela' %(g+1)) 
                print('expressão: %dx+%dy.\n' %(m, M))

                for j in range(m):
                    for i in range(m):
                        temp = solve(m*x + M*j==g+i+1, x)[0].rhs()
                        if temp in ZZ:
                            dic.update({(g+i+1):[temp, j]})
                    
                for j in range(g+1, g+m+1):
                    print('%d*(%d+t) + %d*%d = %d + %d*t' %(m,dic[j][0],M,dic[j][1],j,m))
        num_frob(a,b)

    </slate>
    </interactive>        
</figure>
<p>
O código para calcular o número de Frobenius para duas variáveis e uma parametrização para a solução geral segue abaixo:
</p>
<sage>
<input>def num_frob(a,b):
    if gcd(a, b)!=1:
        print('Insira valores tais que o mdc seja igual a 1.')
    else:
        g = a*b-a-b
        print('g = %d*%d-%d-%d=%d' %(a, b, a, b, g))
        m = min([a,b])
        M = max([a,b])
        l=[]
        dic={}
        temp=0
        
        print('Abaixo, sendo t inteiro não negativo, temos uma')
        print('parametrização para obter qualquer valor inteiro,') 
        print('maior ou igual a %d que pode ser obtido pela' %(g+1)) 
        print('expressão: %dx+%dy.\n' %(m, M))

        for j in range(m):
            for i in range(m):
                temp = solve(m*x + M*j==g+i+1, x)[0].rhs()
                if temp in ZZ:
                    dic.update({(g+i+1):[temp, j]})
            
        for j in range(g+1, g+m+1):
            print('%d*(%d+t) + %d*%d = %d + %d*t' %(m,dic[j][0],M,dic[j][1],j,m))
num_frob(3,8)
</input>
<output>
</output>
</sage>

</technology>


<!-- <technology>

<p>
Número de Frobenius para 3 variáveis.
</p>
<figure width="100%">
    <caption></caption>
    <interactive xml:id="interactive-frobenius3" platform="sage"  aspect="1:1" >
    <slate surface="sage">                    
@interact
def _(a=input_box(6 , width=10,  label="a:"), b=input_box(9 , width=10,  label="b:"), c=input_box(20 , width=10,  label="b:")):

    def sol_frob_3(a,b,c):
        x,y,z = var('x,y,z')
        l = [a,b,c]
        l.sort()
        dic={}
        lista_min=[]
        i=0
        while l[0]>len(dic):
            for y in range(l[0]):
                for z in range(l[0]):
                    temp  = solve_diophantine(l[0]*x+l[1]*y+l[2]*z == i, x)
                    if temp in ZZ and temp>=0 and ((i) not in dic.keys()):
                        if len(dic)==0:
                            dic.update({(i):[temp, y, z]})
                        elif i==max(dic.keys())+1:
                            dic.update({(i):[temp, y, z]})
                        else:
                            dic={}
                        
            i=i+1
        
        frob = min(dic.keys())-1
        print('O último valor sem solução é %d.' %frob)
        print('\n')
        print('Abaixo, sendo t inteiro não negativo, temos uma \nparametrização para obter qualquer valor inteiro, \nmaior ou igual a %d, que pode ser obtido pela \nexpressão: %dx+%dy+%dz.' %(frob+1, l[0], l[1], l[2]))
        print('\n')
        for k in dic.keys():
            print('%d*(%d+t)+%d*%d+%d*%d = %d + %d*t' %(l[0], dic[k][0], l[1], dic[k][1], l[2], dic[k][2], k, l[0]))
        
        #return dic
    sol_frob_3(a,b,c)
    

    

    </slate>
    </interactive>        
</figure>
</technology>


<proposition>
<p>
Dados os inteiros positivos <m>a</m> e <m>b</m> com <m>mdc(a, b) = 1</m>, existem exatamente
<me> \frac{(a-1)(b-1)}{2}. </me>
números inteiros não negativos que não são da forma <m>ax + by</m> com <m>x, y \geq 0</m>.
</p>
</proposition>

<technology>

<p>Implementação para calcular a quantidade de valores e os valores que não são da forma <m>ax + by</m> com <m>x, y \geq 0</m>.
</p>
<figure width="100%">
    <caption></caption>
    <interactive xml:id="interactive-naosol" platform="sage"  aspect="1:0.6" >
    <slate surface="sage">                    
@interact
def _(a1=input_box(5 , width=10,  label="a:"), b1=input_box(9 , width=10,  label="b:")):


    def proposicao_3_6(a,b):
        if (gcd(a,b)==1):
            t = (a-1)*(b-1)/2
            print('Quantidade que não pode ser obtida: \n(%d-1)(%d-1)/2 = %d' %(a,b,t))

            a1 = min([a,b])
            b1 = max([a,b])
            print('\nVariando y de %d até %d:' %(1,a1-1))
            l=[]
            for y in range(1,a1):
                for i in range(1,y*b1//a1+1):
                    l.append(b1*y-a1*i)
                l.sort()
                print('y=%d, %d>=x>0: %dy-%dx sols: %s' %(y, y*b1//a1,b1,a1 ,l))
                l=[]
        else:
            print('Insira valores tais que o mdc seja igual a 1.')
    proposicao_3_6(a1,b1)
    

    </slate>
    </interactive>        
</figure>

<sage>
<input>def proposicao_3_6(a,b):
    if (gcd(a,b)==1):
        t = (a-1)*(b-1)/2
        print('Quantidade que não pode ser obtida: \n(%d-1)(%d-1)/2 = %d' %(a,b,t))

        a1 = min([a,b])
        b1 = max([a,b])
        print('\nVariando y de %d até %d:' %(1,a1-1))
        l=[]
        for y in range(1,a1):
            for i in range(1,y*b1//a1+1):
                l.append(b1*y-a1*i)
            l.sort()
            print('y=%d, %d>=x>0: %dy-%dx sols: %s' %(y, y*b1//a1,b1,a1 ,l))
            l=[]
    else:
        print('Insira valores tais que o mdc seja igual a 1.')
proposicao_3_6(5,9)
</input>
<output>
</output>
</sage>

</technology> -->


</section>
















</article>
</pretext>
