<!DOCTYPE html>
<html lang="pt-BR">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*       on 2024-08-22T15:39:49-03:00       *-->
<!--*   A recent stable commit (2020-08-09):   *-->
<!--* 98f21740783f166a773df4dc83cab5293ab63a4a *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>$(function () {
    // Make *any* div with class 'sagecell-sage' an executable Sage cell
    // Their results will be linked, only within language type
    sagecell.makeSagecell({inputLocation: 'div.sagecell-sage',
                           linked: true,
                           languages: ['sage'],
                           evalButtonText: 'Evaluate (Sage)'});
});
</script>
</head>
<body>
<article class="technology computation-like"><h6 xmlns:svg="http://www.w3.org/2000/svg" class="heading">
<span class="type">Tecnologia</span><span class="space"> </span><span class="codenumber">3.4</span><span class="period">.</span>
</h6>
<p xmlns:svg="http://www.w3.org/2000/svg">Número de Frobenius para "três moedas".</p>
<figure class="figure figure-like"><iframe xmlns:svg="http://www.w3.org/2000/svg" id="interactive-frobenius-3" width="600" height="300" src="interactive-frobenius-3-if.html"></iframe><figcaption xmlns:svg="http://www.w3.org/2000/svg"><span class="type">Figura</span><span class="space"> </span><span class="codenumber">3.5<span class="period">.</span></span><span class="space"> </span></figcaption></figure><p xmlns:svg="http://www.w3.org/2000/svg">O código para calcular o número de Frobenius para "três moedas" segue abaixo:</p>
<div class="sagecell-sage" id="sage-13"><script type="text/x-sage">def frobenius_3(a1, a2, a3): #rodseth
    
    d = gcd(a1, gcd(a2,a3))
    if d>1:
        return 'Escolha 3 números relativamente primos'
    
    d=gcd(a1, a2)       # caso mdc(a1,a2)>1
    if d>1:             # precisamos aplicar
        a1=a1/d         # Theorem 2.3.1, pag. 36
        a2=a2/d         # da referência [??????]
    
    if a3 > a1*a2-a1-a2:
        g = d*(a1*a2-a1-a2)+(d-1)*a3
        #print(1)
        return g
    
    
    s0 = ZZ(solve_mod([a2*x==a3], a1)[0][0])   #cálculo do s0

    s={0:s0}   # cria o dicionário dos si's    
    q={}       # cria o dicionário dos qi's    
    #print('s0:', s0)
    if s[0]!=0:                                # calcula e guarda
        if s[0]>1:
            q.update({1:((int(a1/s[0]))+1)})       # nos respectivos
            s.update({1:(q[1]*s[0]-a1)})           # dicionários
        else:
            q.update({1:((int(a1/s[0])))})       # nos respectivos
            s.update({1:(q[1]*s[0]-a1)})           # dicionários
    else:                                      
        g = a1*a2*d -a1*d - a2*d +(d-1)*a3   # caso s0=0 aplica Theorem 2.3.2
        #print(2)
        return g
    
    i=1                                                  #
    while s[i]!=0:                                       #
        if (int(s[i-1]/s[i]))!= (s[i-1]/s[i]):           # calcula e guarda
            q.update({(i+1):(int((s[i-1]/s[i]))+1)})     # nos respectivos
            #print(i, s)
            s.update({(i+1):(q[i+1]*s[i]-s[i-1])})       # dicionários
            i=i+1                                        # os valores de qi e si
        else:                                            # para i >= 2
            q.update({(i+1):(int(s[i-1]/s[i]))})         #
            s.update({(i+1):(0)})                        #
            #print(i, s)
            i=i+1                                        #
            
        
    p = {-1:0, 0:1, 1:(q[1]*1 - 0)}  # cria o dicionário dos pi's com i=-1, 0, 1 
    r={0:(s[0]*a2-p[0]*a3)/a1} # cria o dicionário dos ri's
    #print('***', s[0]/p[0])
    if 0>=r[0]:                                          #
        v=0                                              # calcula e guarda
    else:                                                # nos respectivos
        i=1                                              # dicionários
        
        while r[i-1]>0:                                  # os valores de pi e ri
            p.update({i+1:(q[i+1]*p[i] - p[i-1])})       # i>=2 para pi e
            r.update({i:((s[i]*a2-p[i]*a3)/a1)})         # i>=1 para ri
            i+=1                                         # 
        v=i-2                                            # 
    #print('s:', s)
    #print('q:', q)
    #print('p:', p)
    #print('r:', r)
    #print('v:', v)
    #print([a2*s[v+1], a3*p[v]])
    g = -a1+a2*(s[v]-1) +a3*(p[v+1]-1) - min([a2*s[v+1], a3*p[v]])  # calcula o valor de g
    #print(g)
    if d==1:                      # caso mdc(a1, a2) = 1 o valor de g já está pronto
        return g
    else:                         # caso mdc(a1, a2) > 1 aplicamos Theorem 2.3.1, pag. 36
        return d*g +(d-1)*a3    
frobenius_3(6,9,20)
</script></div></article><span class="incontext"><a href="section-3.html#technology-10">[incontext]</a></span>
</body>
</html>
